?quantile
?colMeans
?unlist
mylist = list(a="A",b="B")
unlist(mylist)
mylist = list(a=matrix(1:4,2,2),b=matrix(5:8,2,2))
unlist(mylist)
dim(mylist[[1]])
element.dim = dim(mylist[[1]])
list.len = length(mylist)
my.list = list()
my.list = list()
my.list[[1]] = rnorm(1000, 1, 5)
my.list[[2]] = rnorm(1000, 1.2, 5)
my.list[[3]] = rnorm(1000, 1.05, 5)
GelmanRubin(my.list)
GelmanRubin <- function(chain.object, col=0){
#How many chains?
m = length(chain.object)
n = length(chain.object[[1]])
#Calculate within-chain means
chain.means = rep(NA, m)
chain.vars = rep(NA, m)
for (chain.i in 1:m){
if (col != 0){
chain.means[chain.i] = mean(chain.object[[chain.i]][,col])
chain.vars[chain.i] = var(chain.object[[chain.i]][,col])
} else {
chain.means[chain.i] = mean(chain.object[[chain.i]])
chain.vars[chain.i] = var(chain.object[[chain.i]])
}
}
#Global mean
global.mean = mean(chain.means)
#Calculate B
B = var(chain.means)*n
#Calculate W
W = mean(chain.vars)
#Calculate Sigma^2_+
Sigma2.plus = n/(n-1)*W + 1/n*B
#Calculate R.hat
R.hat = sqrt(Sigma2.plus/W)
#Return the scale reduction factor
return(R.hat)
}
GelmanRubin(my.list)
matrix(rnorm(10000, 1, 5), 10, 1000)
matrix(rnorm(10000, 1, 5), 1000, 10)
my.mat.list = list()
my.mat.list[[1]] = matrix(rnorm(10000, 1, 5), 1000, 10)
my.mat.list[[2]] = matrix(rnorm(10000, 1.2, 5), 1000, 10)
my.mat.list[[3]] = matrix(rnorm(10000, 1.05, 5), 1000, 10)
GelmanRubin(my.mat.list, col=3)
?rgb
?brewer.pal
library(RColorBrewer)
?brewer.pal
display.brewer.pal
display.brewer.pal()
display.brewer.pal("BuGn")
display.brewer.all()
brewer.pal(1,"BuGn")
brewer.pal(3,"BuGn")
col2alpha("#E5F5F9")
col2alpha <- function(col, alpha=0.5) {
col_rgb <- col2rgb(col)/255
rgb(col_rgb[1], col_rgb[2], col_rgb[3], alpha = alpha)
}
col2alpha("#E5F5F9")
plot(1:5,1:5, col=col2alpha("#E5F5F9"))
plot(1:5,1:5, col=col2alpha("#E5F5F9",1))
plot(1:5,1:5, col=col2alpha("#E5F5F9",1), type="b")
plot(1:5,1:5, col=col2alpha("#E5F5F9",.2), type="b")
plot(1:5,1:5, col=col2alpha("red",.2), type="b")
plot(1:5,1:5, col=col2alpha("red",.8), type="b")
plot(1:3,1:3, col=col2alpha("red",.8), type="b")
plot(1:3,1:3, col=col2alpha("red",0.3), type="b")
col2rgb("blue")
col2rgb("blue",alpha = .7)
col2rgb("white")
plot(1:3,1:3, col=col2alpha("red",0.3), type="b")
plot(1:3,1:3, col=col2alpha("red",0.9), type="b")
plot(1:3,1:3, col=col2alpha("red",0.8), type="b")
points(3:1,1:3, col=col2alpha("red",0.4))
lines(3:1,1:3, col=col2alpha("red",0.4))
plot(1:3,1:3, col=col2alpha("red",0.8), type="b")
lines(3:1,1:3, col=col2alpha("red",0.2))
plot(1:3,1:3, col=col2alpha("red",0.8), type="b", lwd=2)
lines(3:1,1:3, col=col2alpha("red",0.2), lwd=4)
my.pval <- function(pvals) {
format.pval(pvals, eps = .0001, digits = 3)
}
my.pval(c(0.00000001,0.01,0.9))
plot(1:5,1:5, type="b", main="Example graph")
getwd()
my.png("ExampleGraph.png")
my.png = function(filename, width=6, height=6, unit='in', res=300){
png(filename = filename, width=width, height=height, unit=unit, res=res)
}
my.png("ExampleGraph.png")
plot(1:5,1:5, type="b", main="Example graph")
dev.off()
?pbPost
??pbPost
library(Rpushbullet)
library(RPushbullet)
pbPost("note","R message","is this the body?")
pbPost("note",title="R message2","is this the body?")
file.exists("~/.rpushbullet.json")
findSourceTraceback()
?source
?traceback()
sys.frame(1)
sys.frame(1)
sys.frame(1)$ofile
?sys.frame
?logit
expit = function(input){
exp(input)/(1+exp(input))
}
expit(matrix(1:4,2,2))
my.samples = rnorm(10000, 5, 10)
my.traceplot = function(trace.object,label=NULL,thin=0,burn=0,col="black"){
#Thin if requested
my.index = seq_along(traceobject)
if (keep.every!=0) {
my.index = thinby(my.index, keep.every)
traceobject = thinby(traceobject, keep.every)
}
#Plot
rcol = as.vector(col2rgb(col)/255)
plot(traceobject ~ my.index
,type="l"
,ylab = "Estimate"
,xlab = "Iteration"
,xlim = c(0,max(my.index))
,yaxs='i'
,xaxs='i'
,col = rgb(rcol[1], rcol[2], rcol[3], alpha=0.3)
,main = label)
if (burn !=0){
usr <- par('usr')
rect(usr[1], usr[3], burn, usr[4], col=rgb(1,0,0,alpha=0.2),border=NA)
}
}
my.traceplot(my.samples,label="NULL"My samples",thin=5,burn=100,col="blue")
my.traceplot(my.samples,label=My samples",thin=5,burn=100,col="blue")
my.traceplot(my.samples,label="Some title",thin=5,burn=100,col="blue")
my.samples = rnorm(10000, 5, 10)
my.traceplot(my.samples,label="Some title",thin=5,burn=100,col="blue")
my.traceplot = function(trace.vec,label=NULL,thin=0,burn=0,col="black"){
#Thin if requested
my.index = seq_along(trace.vec)
if (keep.every!=0) {
my.index = thinby(my.index, keep.every)
trace.vec = thinby(trace.vec, keep.every)
}
#Plot
rcol = as.vector(col2rgb(col)/255)
plot(trace.vec ~ my.index
,type="l"
,ylab = "Estimate"
,xlab = "Iteration"
,xlim = c(0,max(my.index))
,yaxs='i'
,xaxs='i'
,col = rgb(rcol[1], rcol[2], rcol[3], alpha=0.3)
,main = label)
if (burn !=0){
usr <- par('usr')
rect(usr[1], usr[3], burn, usr[4], col=rgb(1,0,0,alpha=0.2),border=NA)
}
}
my.samples = rnorm(10000, 5, 10)
my.traceplot(my.samples,label="Some title",thin=5,burn=100,col="blue")
my.traceplot = function(trace.vec,label=NULL,thin=0,burn=0,col="black"){
#Thin if requested
my.index = seq_along(trace.vec)
if (thin!=0) {
my.index = thinby(my.index, thin)
trace.vec = thinby(trace.vec, thin)
}
#Plot
rcol = as.vector(col2rgb(col)/255)
plot(trace.vec ~ my.index
,type="l"
,ylab = "Estimate"
,xlab = "Iteration"
,xlim = c(0,max(my.index))
,yaxs='i'
,xaxs='i'
,col = rgb(rcol[1], rcol[2], rcol[3], alpha=0.3)
,main = label)
if (burn !=0){
usr <- par('usr')
rect(usr[1], usr[3], burn, usr[4], col=rgb(1,0,0,alpha=0.2),border=NA)
}
}
my.traceplot(my.samples,label="Some title",thin=5,burn=100,col="blue")
my.traceplot = function(trace.vec,label=NULL,thin=0,burn=0,col="black"){
#Thin if requested
my.index = seq_along(trace.vec)
if (thin!=0) {
my.index = thinby(my.index, thin)
trace.vec = trace.vec[seq(1,length(trace.vec),thin)]
}
#Plot
rcol = as.vector(col2rgb(col)/255)
plot(trace.vec ~ my.index
,type="l"
,ylab = "Estimate"
,xlab = "Iteration"
,xlim = c(0,max(my.index))
,yaxs='i'
,xaxs='i'
,col = rgb(rcol[1], rcol[2], rcol[3], alpha=0.3)
,main = label)
if (burn !=0){
usr <- par('usr')
rect(usr[1], usr[3], burn, usr[4], col=rgb(1,0,0,alpha=0.2),border=NA)
}
}
my.traceplot(my.samples,label="Some title",thin=5,burn=100,col="blue")
my.traceplot = function(trace.vec,label=NULL,thin=0,burn=0,col="black"){
#Thin if requested
my.index = seq_along(trace.vec)
if (thin!=0) {
my.index = my.index[seq(1,length(trace.vec),thin)]
trace.vec = trace.vec[seq(1,length(trace.vec),thin)]
}
#Plot
rcol = as.vector(col2rgb(col)/255)
plot(trace.vec ~ my.index
,type="l"
,ylab = "Estimate"
,xlab = "Iteration"
,xlim = c(0,max(my.index))
,yaxs='i'
,xaxs='i'
,col = rgb(rcol[1], rcol[2], rcol[3], alpha=0.3)
,main = label)
if (burn !=0){
usr <- par('usr')
rect(usr[1], usr[3], burn, usr[4], col=rgb(1,0,0,alpha=0.2),border=NA)
}
}
my.traceplot(my.samples,label="Some title",thin=5,burn=100,col="blue")
my.traceplot(my.samples,label="Some title",thin=5,burn=1000,col="blue")
add.chain = function(trace.vec, thin=0, col="black"){
my.index = seq_along(trace.vec)
if (thin!=0) {
my.index = my.index[seq(1, length(trace.vec), thin)]
trace.vec = trace.vec[seq(1, length(trace.vec), thin)]
}
rcol = as.vector(col2rgb(col)/255)
lines(x = my.index, y = trace.vec
, col = rgb(rcol[1], rcol[2], rcol[3], alpha=0.3))
}
my.samples2 = rnorm(10000, 5, 2)
add.chain(my.samples2,thin=5,col="green")
my.samples2 = rnorm(10000, 5, 20)
my.traceplot(my.samples,label="Some title",thin=5,burn=1000,col="blue")
add.chain(my.samples2,thin=5,col="green")
?acf
my.acfplot = function(acfplot.vec,label=NULL,thin=0,burn=0,lag.max=100){
#Thin if requested (probably won't be, but whatever)
my.index = seq_along(acfobject)
if (keep.every!=0) {
my.index = my.index[seq(1,length(acfplot.vec),thin)]
acfplot.vec = acfplot.vec[seq(1,length(acfplot.vec),thin)]
}
#Plot
acf(acfobject, lag.max = lag.max, main = label)
}
my.samples = rnorm(10000, 5, 10)
my.acfplot(my.samples,label="Some title",thin=5,burn=1000,lag.max=30)
my.acfplot = function(acfplot.vec,label=NULL,thin=0,burn=0,lag.max=100){
#Thin if requested (probably won't be, but whatever)
my.index = seq_along(acfplot.vec)
if (keep.every!=0) {
my.index = my.index[seq(1,length(acfplot.vec),thin)]
acfplot.vec = acfplot.vec[seq(1,length(acfplot.vec),thin)]
}
#Plot
acf(acfobject, lag.max = lag.max, main = label)
}
my.acfplot(my.samples,label="Some title",thin=5,burn=1000,lag.max=30)
my.acfplot = function(acfplot.vec,label=NULL,thin=0,burn=0,lag.max=100){
#Thin if requested (probably won't be, but whatever)
my.index = seq_along(acfplot.vec)
if (thin!=0) {
my.index = my.index[seq(1,length(acfplot.vec),thin)]
acfplot.vec = acfplot.vec[seq(1,length(acfplot.vec),thin)]
}
#Plot
acf(acfobject, lag.max = lag.max, main = label)
}
my.acfplot(my.samples,label="Some title",thin=5,burn=1000,lag.max=30)
my.acfplot = function(acfplot.vec,label=NULL,thin=0,burn=0,lag.max=100){
#Thin if requested (probably won't be, but whatever)
my.index = seq_along(acfplot.vec)
if (thin!=0) {
my.index = my.index[seq(1,length(acfplot.vec),thin)]
acfplot.vec = acfplot.vec[seq(1,length(acfplot.vec),thin)]
}
#Plot
acf(acfplot.vec, lag.max = lag.max, main = label)
}
my.acfplot(my.samples,label="Some title",thin=5,burn=1000,lag.max=30)
matrix(rnorm(10000,1:10,1),10,1000)
matrix(rnorm(10000,1:10,1),1000,10)
head(matrix(rnorm(10000,1:10,1),1000,10))
head(t(matrix(rnorm(10000,1:10,1),1000,10)))
t(matrix(rnorm(10000,1:10,1),10,1000))
matrix(rnorm(10000,1:10,1),10,1000)
matrix(rnorm(10000,1:10,0.1),10,1000)
matrix(rnorm(10000,rep(1:10,time=1000),0.1),10,1000)
matrix(rnorm(10000,rep(1:10,time=1000),0.1),1000,10)
matrix(rnorm(10000,rep(1:10,times=1000),0.1),1000,10)
matrix(rnorm(10000,rep(1:10,each=1000),0.1),1000,10)
my.matrix = matrix(rnorm(10000,rep(1:10,each=1000),0.1),1000,10)
colMeans(my.matrix)
my.matrix = matrix(rnorm(10000,rep(1:10,each=1000),0.5),1000,10)
getPostMeanMedCI = function(getPostMeanMedCI.mat, alpha=0.05){
#Calculate
result = cbind(colMeans(getPostMeanMedCI.mat)
,colMedians(getPostMeanMedCI.mat)
,makeCIs(getPostMeanMedCI.mat, alpha=alpha))
#Make pretty
colnames(result)[1:2] = c("Post. Mean", "Post Median")
rownames(result) = colnames(getPostMeanMedCI.mat)
#Return
return(result)
}
getPostMeanMedCImy.matrix)
getPostMeanMedCI(my.matrix)
my.matrix = matrix(rnorm(5000,rep(1:5,each=1000),0.5),1000,5)
getPostMeanMedCI(my.matrix)
getMeanSDCI <- function(getMeanSDCI.obj, alpha=0.05){
#Parameter checking if possible
if (require(assertthat)){
assert_that(is.matrix(getMeanSDCI.obj) | is.data.frame(getMeanSDCI.obj))
}
#Calculate
result = cbind(colMeans(getMeanSDCI.obj)
,colMedians(getMeanSDCI.obj)
,makeCIs(getMeanSDCI.obj, alpha=alpha))
#Make pretty
colnames(result)[1:2] = c("Post. Mean", "Post Median")
rownames(result) = colnames(getMeanSDCI.obj)
#Return
return(result)
}
my.matrix = matrix(rnorm(5000,rep(1:5,each=1000),0.5),1000,5)
getMeanSDCI(my.matrix)
getMeanSDCI <- function(getMeanSDCI.obj, alpha=0.05){
#Parameter checking if possible
if (require(assertthat)){
assert_that(is.matrix(getMeanSDCI.obj) | is.data.frame(getMeanSDCI.obj))
}
#Convert to data frame, taking column names as descriptions
getMeansSDCI.obj = as.data.frame(getMeansSDCI.obj)
parameters = colnames(getMeansSDCI.obj)
#Calculate desired numbers
means = apply(getMeansSDCI.obj,2,mean)
sds = apply(getMeansSDCI.obj,2,sd)
LBs = apply(getMeansSDCI.obj,2,quantile,probs=alpha/2)
UBs = apply(getMeansSDCI.obj,2,quantile,probs=1-alpha/2)
#Make table
result0 = as.data.frame(cbind(means,sds,LBs,UBs))
result = cbind(parameters,result0)
rownames(result) = NULL
colnames(result) = c("Parameter","Mean", "SD", "95% CI LB", "95% CI UB")
return(result)
}
}
getMeanSDCI <- function(getMeanSDCI.obj, alpha=0.05){
#Parameter checking if possible
if (require(assertthat)){
assert_that(is.matrix(getMeanSDCI.obj) | is.data.frame(getMeanSDCI.obj))
}
#Convert to data frame, taking column names as descriptions
getMeansSDCI.obj = as.data.frame(getMeansSDCI.obj)
parameters = colnames(getMeansSDCI.obj)
#Calculate desired numbers
means = apply(getMeansSDCI.obj,2,mean)
sds = apply(getMeansSDCI.obj,2,sd)
LBs = apply(getMeansSDCI.obj,2,quantile,probs=alpha/2)
UBs = apply(getMeansSDCI.obj,2,quantile,probs=1-alpha/2)
#Make table
result0 = as.data.frame(cbind(means,sds,LBs,UBs))
result = cbind(parameters,result0)
rownames(result) = NULL
colnames(result) = c("Parameter","Mean", "SD", "95% CI LB", "95% CI UB")
return(result)
}
my.matrix = matrix(rnorm(5000,rep(1:5,each=1000),0.5),1000,5)
getMeanSDCI(my.matrix)
getMeanSDCI <- function(getMeanSDCI.obj, alpha=0.05){
#Parameter checking if possible
if (require(assertthat)){
assert_that(is.matrix(getMeanSDCI.obj) | is.data.frame(getMeanSDCI.obj))
}
#Convert to data frame, taking column names as descriptions
getMeanSDCI.obj = as.data.frame(getMeanSDCI.obj)
parameters = colnames(getMeanSDCI.obj)
#Calculate desired numbers
means = apply(getMeanSDCI.obj,2,mean)
sds = apply(getMeanSDCI.obj,2,sd)
LBs = apply(getMeanSDCI.obj,2,quantile,probs=alpha/2)
UBs = apply(getMeanSDCI.obj,2,quantile,probs=1-alpha/2)
#Make table
result0 = as.data.frame(cbind(means,sds,LBs,UBs))
result = cbind(parameters,result0)
rownames(result) = NULL
colnames(result) = c("Parameter","Mean", "SD", "95% CI LB", "95% CI UB")
return(result)
}
getMeanSDCI(my.matrix)
getMeanSDCI <- function(getMeanSDCI.df, alpha=0.05){
#Parameter checking if possible
if (require(assertthat)){
assert_that(is.data.frame(getMeanSDCI.df))
}
#Take column names as descriptions
parameters = colnames(getMeanSDCI.df)
#Calculate desired numbers
means = apply(getMeanSDCI.df,2,mean)
sds = apply(getMeanSDCI.df,2,sd)
LBs = apply(getMeanSDCI.df,2,quantile,probs=alpha/2)
UBs = apply(getMeanSDCI.df,2,quantile,probs=1-alpha/2)
#Make table
result0 = as.data.frame(cbind(means,sds,LBs,UBs))
result = cbind(parameters,result0)
rownames(result) = NULL
colnames(result) = c("Parameter","Mean", "SD", "95% CI LB", "95% CI UB")
return(result)
}
getMeanSDCI(my.matrix)
assert_that(is.data.frame(getMeanSDCI.df))
my.df = as.data.frame(matrix(rnorm(5000,rep(1:5,each=1000),0.5),1000,5))
getMeanSDCI(my.df)
my.kable <- function(my.kable.obj, caption=NULL, digits=4, latexTranslate=FALSE
, greek=TRUE, prettyNum=TRUE){
#Figure out which things are numeric (need to right-align)
aligns = rep("l",ncol(my.kable.obj))
my.kable.obj = as.data.frame(my.kable.obj)
numcols = which(as.logical(sapply(my.kable.obj,is.numeric)))
aligns[numcols] = "r"
alignment = paste(aligns,collapse="")
alignment = paste0("{",alignment,"}")
pastething2 = paste0("\\begin{table*}[h]\\centering\\begin{tabular}"
,alignment)
#Format numbers
if (prettyNum == TRUE) {
my.kable.obj = prettyNum(my.kable.obj, digits=digits)
} else {
my.kable.obj[,numcols] = formatC(my.kable.obj[,numcols], digits=digits)
}
#Make the caption, if applicable
if (length(caption) > 0){
pastething2 = paste0("\\begin{table*}[h]\\caption*{",caption
,"}\\centering\\begin{tabular}",alignment)
} else {
pastething2 = paste0("\\begin{table*}[h]\\centering\\begin{tabular}"
,alignment)
}
#Write the latex
if (latexTranslate==TRUE){
gsub("\\&", "&"
,gsub("\\end{tabular}", "\\end{tabular}\\end{table*}"
,gsub("\\begin{tabular}", pastething2
,gsub("\\addlinespace", ""
,gsub(pattern = "\\{[lrc]*\\}", replacement=""
,latexTranslate(kable(my.kable.obj
,format="latex"
,booktabs=TRUE)
,greek=greek))
,fixed=TRUE)
,fixed=TRUE)
,fixed=TRUE)
,fixed=TRUE)
} else {
gsub("\\&", "&"
,gsub("\\end{tabular}", "\\end{tabular}\\end{table*}"
,gsub("\\begin{tabular}", pastething2
,gsub("\\addlinespace", ""
,gsub(pattern = "\\{[lrc]*\\}", replacement=""
,kable(my.kable.obj,format="latex"
,booktabs=TRUE))
,fixed=TRUE)
,fixed=TRUE)
,fixed=TRUE)
,fixed=TRUE)
}
}
10^(-1:-3)
my.table = data.frame(ABCs = LETTERS[1:3], betas=1:3, values=10^(-1:-3))
my.kable(my.table)
library(knitr)
my.kable(my.table)
library(Hmisc)
my.kable(my.table)
my.kable(my.table, latexTranslate=TRUE, greek=TRUE)
my.table = data.frame(ABCs = LETTERS[1:3], beta=1:3, values=10^(-1:-3))
my.kable(my.table, latexTranslate=TRUE, greek=TRUE)
library(devtools)
library(roxygen2)
setwd("c:/users/leahcomment/packages")
setwd("c:/users/leahcomment/packages/ltools")
document()
document()
